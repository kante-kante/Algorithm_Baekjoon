# 1931 - 회의실 배정
```
문제
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 
각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 
각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자.
단, 회의는 한번 시작하면 중간에 중단될 수 없으며 
한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 
회의의 시작시간과 끝나는 시간이 같을 수도 있다. 
이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

입력
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 
둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 
시작 시간과 끝나는 시간은 2^31-1보다 작거나 같은 자연수 또는 0이다.

출력
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.
```

## 풀이
1개의 회의실에 회의시간을 배치하는 그리디 알고리즘 프로그램.   
다음 3개의 조건에 맞추어야 한다.
```
조건
1. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며
2. 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
3. 회의의 시작시간과 끝나는 시간이 같을 수도 있다.(이 경우에는 시작하자마자 끝으로 간주.)
```

(1,4), (5,7), (8,11), (12,14) 처럼 앞시간의 회의가 끝나야만 다음 회의를 진행할수 있다.   
또한, (1,1), (1,2)등과 같이 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있으며
회의의 시작시간과 끝나는 시간이 같을 수도 있다. (출력 결과는 2)

해당 문제를 해결하기 위해서는 정렬조건을 지정하여   
끝나는 시간을 먼저 오름차순 정렬하고 다시 시작시간을 정렬해주어야 한다.   
(이유는 먼저 회의가 끝나는 시간에 맞추고 다시 회의가 끝난 시간부터 회의실을 배치해야 하기 때문.)

### #1
```py
n = int(input())
meeting = []

for i in range(n):
    start, end = map(int,input().split())
    meeting.append([start,end])

meeting.sort(key = lambda x: (x[1],x[0]))
```
먼저 회의의 수를 입력받고 반복문을 이용하여 회의 수 만큼 배열에 삽입한다.
그다음 정렬조건을 지정하여 종료시간(x[1]) 먼저 정렬 후, 그다음 시작시간으로 정렬한다.
### #2
```py
end_meeting = 0
cnt = 0
for i in meeting:
    if i[0] >= end_meeting:
        end_meeting = i[1]
        cnt += 1
print(cnt)
```
이후 끝나는 시간에 맞추어 시작시간이 종료시간보다 크거나 같다면 회의가 이미 배정되어 시작된 경우이므로
count를 하나 늘려준다.   
해당 반복문을 모두 탐색하여 결과를 출력한다.

# 소스코드
```py
import sys
input = sys.stdin.readline

n = int(input())
meeting = []

for i in range(n):
    start, end = map(int,input().split())
    meeting.append([start,end])

meeting.sort(key = lambda x: (x[1],x[0]))

end_meeting = 0
cnt = 0
for i in meeting:
    if i[0] >= end_meeting:
        end_meeting = i[1]
        cnt += 1
print(cnt)
```