'''
준규가 가진 동전은 N종류, 각 동전은 매우 많음
동전을 적절히 사용해서 가치의 합을 K로 만듦.이때 필요한 동전 개수의 최솟값 구하기

첫번째 줄에는 N과 K를 입력받고 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순
ex) (10, 4200) -> 10개의 동전 종류, 가치의 합은 4200

먼저 n과 k를 입력받을 수 있도록 하고, 동전의 종류 가짓수만큼 입력받을 수 있도록
배열을 설정한다. 결과값은 result.

for i in range(n) 부분은 n가지의 동전들로 K라는 합을 만들어야 하므로
동전의 가짓수만큼 입력받도록 처리하였다.

배열을 내림차순으로 바꾼 이유는 최솟값을 구하기 위해서는 큰 수부터 나누어 주는 것이
연산이 빠르므로 배열을 역순으로 정렬하였다.

k = 0. 즉, 동전의 가치의 합이 0이면 동전이 필요 없기 때문에 반복문을 탈출하며
결과값인 result가 필요한 동전의 갯수를 반환해야 하므로 몫을 반환한다.
k를 i로 나눈 나머지가 0이 되어야 동전 가치의 합이 알맞게 떨어지므로 나머지를 구하도록 설정. 
'''

n, k = map(int, input().split())
coin =[]
result = 0

for i in range(n):
    coin.append(int(input()))
    
coin.sort(reverse=True) # 내림차순. 최솟값을 출력하기 위해서는 큰수부터 나눈다.

for i in coin:          # i번째 요소가 coin[0]이므로 내림차순으로 바꿔줘야 한다.
    if k == 0:          # K(동전의 가치의 합)이 0이면 동전이 필요 없으므로 break
        break
    result += k // i    # coin의 첫번째 요소부터 나누기 반복. k = 0이면 break
    k %= i              # 나머지가 없어야 딱 맞아 떨어지므로, k가 0이 될 때까지 반복

print(result)
